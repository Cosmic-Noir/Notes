=begin 
Ruby 

- High-level - meaning it is really easy.
- Interpreted - don't need a compiler to write and run Ruby. 
- Object Oriented - allows user to manipualte objects to build and execute programs. Everything in Ruby is an object.
-Easy to use - Designed by Yukihiro Matsumoto (often called "Matz") in 1995. Wanted to designed something that emphasized human needs over those of the computer. 
- NOT camel-case, two word variables are named with a _ between words ex:
    my_name = "Kristen

- Only 3 Data Types in Ruby:
    - Numeric, Boolean, and String. 

Declaring - notice no semi-colon at the end like in javaScript: 
=end

my_num = 25

# Printing to the Console - use 'puts' and 'print'. 
  #   - puts - adds a new blank line after the thing you want it to print. Ex:

    puts "What's up?"
    print"Oxnard Montalvo"

# Methods - methods are summoed with a '.' . Note that if the method ends in an ? it returns a boolean value. Ex:

puts "I love espresso".length

# ==> 15

# - .length - returns length. Ex:

puts "Yay I'm gonna make $$$".length

# - .reverse - returns string backwards. Ex:

puts "Kristen".reverse

# - .upcase/.downcase - convert to upper or lower case. Ex:

puts "Kristen".upcase
puts "Kristen".downcase

# - .capitalize - Capitlizes the first letter of a string and makes the rest lower case. 

# - .include? - checks if the string contains given substring and returns true or false. Ex:

    if string_to_check.include? "substring"

# - .gsub! - "Global Substitution" - Note there is NO space between the ! and (

rb string_to_change.gsub!(/s/, "th") 

# - .sort_by - Can sort an object by either key or values and return an array of arrays? 

# - .split - takes a string and returns an array, takes an argument called a 'delimiter':

text.split("")
text.split(" ")
text.split(",")

# - .to_s - Tuns a number into a string

# Chaining Methods: Can do seperately or chained together:

name = "Kristen".downcase.reverse.upcase

puts name

# Getting Input - 
 # - gets - Ruby method that gets input from user. Auto adds new line after user input.
 # - .chomp - removes extra line if you want. 

 print "What's your first name?"
first_name = gets.chomp

# String Interpolation - uses #{} . 

# Note that if you want to store a modified value in a variable instead of storing in a new value, use ! at the end of a method:

print "What's your first name?"
first_name = gets.chomp
first_name.capitalize!
print "What's your last name?"
last_name = gets.chomp
last_name.capitalize!
print "What city are you from?"
city = gets.chomp
city.capitalize!
print "What state Abreviation are you from?"
state = gets.chomp
state.upcase!

print "#{first_name} #{last_name} is from #{city} #{state}"


# Control Flow - uses if / else / end 

if 1 > 0
  print "Something is very right"
else 
  print "Something is very wrong"
end

# elsif - If there is more than two options 

if 1 > 2
  print "Something is very right"
elsif 
  2 > 3
else 
  print "Something is very wrong"
end

# Example:

me = 30
you = 29

if me < you
  print "You're older than me"
elsif you > me
  print "I'm older than you"
else 
  print "We're the same age!"
end



# unless - if you want to check if something is FALSE. 

hungry = false

unless hungry
  puts "I'm writing Ruby programs!"
else
  puts "Time to eat!"
end

# Another way to use the unless method is like a shortcut if statement:

problem = false
print "Good to go!" unless problem

#  Example:

cost = 1000

print "We can afford it" unless cost > 2000


# Loops and Iterators - while, until, for loops. For loops, like in JS, are for when you know how many times you want to loop. 

i = 0
while i < 5
  puts i
  i = i + 1  
end

# Assignment Operator - link in Javascript, instead of long incrematations of variables, you can use the assignment operators: +=, -=, *=, and /=.

counter += 1

# Inclusive and Exclusive Ranges - When creating a range, there are two syntactical options: .. or ... , where .. indicatses inclusion of the last digit, and ... means up to, but not including the last digit. Ex:

# does NOT include 10 

for num in 1...10
  puts num
end

# does include 15

for num in 1..15
  puts num
end


# Loop Method - You can repeat an action using Ruby's 'iterator' method to repeatedly invoke a block of code. Ex of infinite loop:

loop { print "Hello, world!"}

# {} - In Ruby, these are generally interchangeabel with the keywords 'do' and 'end' to open and close a block of code. With this, we can write a better loop than the above, where 'break' is the break condition used to end the loop if a condition is met:

i = 0
loop do
  i += 1
  print "#{i}"
  break if i > 5
end

# next - keyword used to skip overtain certain iterations in a lop. Ex:

for i in 1..5
  next if i % 2 == 0
  print i
end

# Ex:

i = 20
loop do
  i -= 1
  next if i % 2 != 0
  print "#{i}"
  break if i <= 0
end

# Arrays - 

my_array = [1, 2, 3, 4, 5]

# .each - Applies an expression to each element of an object, one at a time. Where the | | syntax is for whatever you want to call each individual key. Syntax:

object.each {  |item|
  # do something
}

# do - keyword you can use with end instead of {}

object.each do |item|
  # do something
end

# Ex:

odds = [1,3,5,7,9]

odds.each { |x| 
  print x * 2
}

# .times - method that is like a compact 'for' loop. Can perform a task on each item in an object a specified number of times. Ex:

10.times { print "Chunky!" }

# until - looping with unitl - 

# for - Just another way to do things. Ex:

for k in 1..50
    print k
end

# Ex:

n = 0
loop do
  n += 1
  print "Ruby!"
  break if n == 30
end

# .times - ex:

# Example of building a small program :


# Hash Maps - Key value pairs are assigned with the => like so:

hash = {
  key1 => value1,
  key2 => value2,
  key3 => value3
}

# You can also create a new Hash by calling it with the .new method and assigining it to a variable name:

pets = Hash.new

# You can add key value pairs in two ways, by addinto to the hash literal with key value pairs inbetween the brackets, or like this:

pets["Ted"] = "Theodore"

# Accessing the values in an array is the same as JS:

puts pets["Ted"]  # prints Theodore

# Iterating over objects and arrays is similar and you can use .each and you can even use two variables to represent the key value pairs:

friends = ["Milhouse", "Ralph", "Nelson", "Otto"]

family = { "Homer" => "dad",
  "Marge" => "mom",
  "Lisa" => "sister",
  "Maggie" => "sister",
  "Abe" => "grandpa",
  "Santa's Little Helper" => "dog"
}

friends.each { |x| puts "#{x}" }
family.each { |x, y| puts "#{x}: #{y}" }

# You can easily iterate through arrays:

languages = ["HTML", "CSS", "JavaScript", "Python", "Ruby"]

languages.each { |language| 
  puts language
}

# Iterating over mutli dimensional arrays - Creat nested .each loops:

s = [["ham", "swiss"], ["turkey", "cheddar"], ["roast beef", "gruyere"]]

s.each { |array| array.each { |item| puts item}}

# With Hash Maps you have to have two variables, one for each key and value in the map.

secret_identities = {
  "The Batman" => "Bruce Wayne",
  "Superman" => "Clark Kent",
  "Wonder Woman" => "Diana Prince",
  "Freakazoid" => "Dexter Douglas"
}
  
secret_identities.each {|x, y| puts "#{x}: #{y}" }

# Hash maps also take an optional argument of the default value for any key added without a value. Note that if you try to access a key that does not exist, you get the default value.

h = Hash.new(0)
h = Hash.new("default value")

# Example of a small program that takes user input, splits the words into an array, creates a new hash table with a default value of 0, 
then for each word in the array, it adds the word to the hash at a value of 1, or the existing value is increased by 1. Then, the hash
is sorted by the count, then reversed, then another .each loop prints the word and count of each key value pair. 

puts "Please type something:"
text = gets.chomp
words = text.split(" ")

frequencies = Hash.new(0)

words.each { |word | 
frequencies[word] += 1
 }

frequencies = frequencies.sort_by do |word, count|
  count
end

frequencies.reverse!

frequencies.each { |word, count|
  puts word + " " + count.to_s
}